\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{amsmath,amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{array}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\usepackage{textcomp}
\usepackage[spanish,es-tabla]{babel} 
\usepackage{stfloats}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cite}
\usepackage{xcolor}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{listings}
\hyphenation{op-tical net-works semi-conduc-tor IEEE-Xplore}
% updated with editorial comments 8/9/2021
\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}

\lstdefinestyle{codigo}{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\footnotesize,
    frame=single,
    breaklines=true,
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{orange!80!black},
    showstringspaces=false
}
% Headers con fancyhdr
\usepackage{fancyhdr}

% --- Estilo general ---
\fancypagestyle{otherpages}{%
  \fancyhf{}
  \fancyhead[C]{\textbf{Universidad La Salle - Inspira La Salle 2025}}
  \fancyhead[R]{\thepage}
  \renewcommand{\headrulewidth}{0.4pt}
}

\begin{document}

% Aplica estilo
\pagestyle{otherpages}
% =========================================================================
% TÍTULO DEL ARTÍCULO SEGÚN ESTÁNDAR IEEE
% - Fuente: Times New Roman (configurada automáticamente por IEEEtran).
% - Tamaño: 24pt en negrita (definido por IEEEtran).
% - Estilo: Title Case (Mayúscula inicial en palabras importantes).
% - Extensión: conciso, máximo 2 líneas.
% - NO colocar punto final al título.
% - Se recomienda usar \thanks{} para notas adicionales (ej: feria, evento).
% =========================================================================

\title{Especificación Formal de un Sistema de Control de Acceso para Laboratorios en la Universidad La Salle de Arequipa%
\thanks{Presentado en la Feria de Proyectos \textit{Inspira La Salle}, Universidad La Salle, Arequipa, 2025}}

% =========================================================================
% AUTORES SEGÚN ESTÁNDAR IEEE
% - Estructura básica:
%   \author{Nombre Apellido, Nombre Apellido, ...\\
%   Afiliación institucional (Universidad, Escuela, Facultad)\\
%   Correo(s) electrónico(s)}
%
% - Cada autor debe tener su nombre completo (primero nombres, luego apellidos).
% - Las afiliaciones deben ir claras y breves (ej: "Universidad La Salle, Arequipa, Perú").
% - Los correos electrónicos se pueden listar en una sola línea o separados.
% - El uso de \thanks{} es opcional, para agradecimientos especiales
%   (ejemplo: financiamiento, patrocinio o mención de feria).
% =========================================================================

\author{
    \IEEEauthorblockN{
        Jhordan Huamaní Huamaní\textsuperscript{1},
        Jorge Ortiz Castañeda\textsuperscript{1},
        José Mamani Zuñiga\textsuperscript{1},
        Miguel Flores León\textsuperscript{1}
    }
    \IEEEauthorblockA{
        \textsuperscript{1}Departamento de Ingeniería de Software, Universidad La Salle de Arequipa, Perú \\
        \{jhordanhh, jortizc, jmamamniz, mfloresl\}@ulasalle.edu.pe
    }
}

\maketitle

% =========================================================================
% ABSTRACT SEGÚN ESTÁNDAR IEEE
% - Se coloca justo después del bloque de autores.
% - Fuente: Times New Roman, tamaño 9pt, en un solo párrafo justificado.
% - No debe tener sangría (IEEEtran ya lo configura automáticamente).
% - Extensión: típicamente entre 150 y 250 palabras.
% - Escrito en presente/tercera persona, objetivo y conciso.
% - No se permiten referencias, citas o abreviaturas no definidas en el abstract.
% =========================================================================

\begin{abstract}
Este artículo presenta el desarrollo del proyecto \textit{Especificación Formal de un Sistema de Control de Acceso para Laboratorios en la Universidad La Salle de Arequipa}, realizado por estudiantes de la Universidad La Salle y expuesto en la Feria de Proyectos \textit{La Salle In-Genio} 2025. El objetivo principal es diseñar la especificación formal del sistema (SICA-L) utilizando VDM++, abordando la vulnerabilidad de los equipos de alto valor y la actual falta de trazabilidad. La propuesta consiste en validar el modelo mediante herramientas como VDM++ Toolbox y NuSMV, destacando su contribución en términos de seguridad preventiva y la generación de un diseño libre de ambigüedades. Finalmente, se discuten los resultados preliminares y el potencial de aplicación en futuras implementaciones para instituciones de educación superior.
\end{abstract}

% =========================================================================
% IEEE KEYWORDS SEGÚN ESTÁNDAR IEEE
% - Se colocan inmediatamente después del abstract.
% - Fuente: Times New Roman, tamaño 9pt, en cursiva (lo maneja IEEEtran).
% - Deben ser de 3 a 6 palabras o frases cortas, separadas por comas.
% - No repetir palabras exactas del título, salvo que sea indispensable.
% - Usar términos específicos que faciliten la indexación (ej: "Machine Learning"
%   en lugar de "Algorithms").
% - Extensión: máximo ~5–6 keywords.
% - IEEE recomienda usar términos técnicos estandarizados (si existe un IEEE Taxonomy para tu área).
% =========================================================================
\begin{IEEEkeywords}
Especificación formal, Modelos de control de acceso, Sistema de control de acceso, Verificación de modelos
\end{IEEEkeywords}

% =========================================================================
% INTRODUCTION SEGÚN ESTÁNDAR IEEE
% - Primera sección numerada: \section{Introduction}.
% - Debe comenzar con \IEEEPARstart{} para dar estilo a la primera letra capital.
% - Extensión típica: 1 a 2 páginas (para papers cortos, 2–3 párrafos).
% - Contenido recomendado:
%   1) Contexto general del problema o área de estudio.
%   2) Importancia o motivación (¿por qué es relevante?).
%   3) Limitaciones o vacíos en el estado del arte.
%   4) Propósito y contribuciones principales del proyecto.
% - Evitar citas en exceso aquí; se suelen incluir en "Related Work".
% =========================================================================

\section{Introducción} \IEEEPARstart{L}{a} Universidad La Salle de Arequipa ha emprendido un proceso de modernización de su infraestructura tecnológica y académica, incorporando laboratorios con equipamiento de alto valor. En este contexto, surge la necesidad crítica de implementar un sistema que permita controlar, registrar y auditar los accesos a dichos espacios de manera formal y verificable. La gestión eficiente de estos recursos exige soluciones que garanticen no solo la seguridad física, sino también la trazabilidad inequívoca de las operaciones realizadas por el personal autorizado.

Los sistemas tradicionales de control, basados frecuentemente en registros manuales o mecanismos informales, resultan insuficientes ante los estándares actuales de seguridad. Esta carencia evidencia la vulnerabilidad ante errores humanos y dificulta la auditoría forense en caso de incidentes. Por consiguiente, resulta imperativo diseñar un mecanismo automatizado que incorpore criterios formales para eliminar ambigüedades, inconsistencias lógicas y brechas de seguridad que podrían comprometer la integridad institucional.

El presente artículo introduce el proyecto \textit{Especificación Formal de un Sistema de Control de Acceso para Laboratorios (SICA-L)}, desarrollado por estudiantes de la Universidad La Salle y expuesto en la Feria de Proyectos \textit{La Salle In-Genio 2025}. La propuesta central consiste en la aplicación de métodos formales, específicamente el lenguaje VDM++, para modelar las operaciones críticas del sistema tales como autenticación, autorización y registro asegurando la corrección matemática del diseño antes de su codificación.

Más allá de la especificación, el modelo es sometido a una rigurosa validación y verificación: se emplea análisis de cobertura para la lógica interna y herramientas de \textit{model checking} como NuSMV y UPPAAL para garantizar el cumplimiento de propiedades de seguridad y restricciones de tiempo real. De este modo, el trabajo establece un \textit{blueprint} formal y robusto, sirviendo como referencia replicable para futuras implementaciones en entornos académicos y de alta seguridad.

% Si buscan más formas de poer agregar: tablas, imagenes, cuadros y otros elementos relevantes, en el final del código existe una guia de algunos elementos comunes que pueden encontrar para esta plantilla.

% =========================================================================
% SECCIONES PRINCIPALES DEL ARTÍCULO
% =========================================================================

% -----------------------------------------------------------
% 1) TRABAJOS ANTERIORES / STATE OF THE ART
% -----------------------------------------------------------
\section{Trabajos anteriores}
% Breve resumen de investigaciones previas relacionadas con tu proyecto.
% Incluir citas bibliográficas con \cite{}.
% Ejemplo:
% Varios estudios han abordado el problema de X \cite{ref1,ref2}.
% Se destacan los métodos A \cite{ref3} y B \cite{ref4}, los cuales presentan limitaciones en...
% Recomendación: utilizar subsecciones si hay varias líneas de trabajo.
% \subsection{Enfoque A}
% \subsection{Enfoque B}
La aplicación de métodos formales para la especificación y verificación de sistemas de control de acceso es un campo de investigación bien establecido, ya que la seguridad y la fiabilidad son requisitos no negociables en estos sistemas. El presente trabajo se sitúa en la intersección de varias áreas de investigación consolidadas.

El uso del \textit{Vienna Development Method} (VDM) y su extensión orientada a objetos, VDM++, para modelar sistemas críticos tiene una larga trayectoria. Autores como Bryans y Fitzgerald han demostrado cómo VDM++ puede ser utilizado para la ingeniería formal de políticas de control de acceso complejas, como las expresadas en XACML, permitiendo un análisis riguroso antes de la implementación \cite{bryans2008formal}. La versatilidad de VDM++ también se ha demostrado en la especificación de sistemas industriales, como los sistemas de autodefensa para aeronaves de combate, donde la precisión del modelo es fundamental para garantizar la seguridad operacional \cite{mukherjee1997computer}. Además, su aplicación se extiende a sistemas de transacciones seguras, como monederos electrónicos, donde la especificación formal ha sido clave para detectar errores sutiles en el código fuente \cite{stephens1996mondex}.

El \textit{model checking} es la técnica de verificación por excelencia para encontrar fallos en sistemas concurrentes y de seguridad \cite{clarke2018model}. Herramientas como NuSMV y SPIN se han utilizado extensamente para analizar protocolos de seguridad y encontrar vulnerabilidades que las pruebas manuales no logran detectar, como en el famoso caso del protocolo Needham-Schroeder \cite{lowe1996breaking}. Se ha empleado, por ejemplo, para validar políticas de control de acceso expresadas en SecureUML, traduciéndolas a un lenguaje formal como B para realizar pruebas sistemáticas de permisos de roles \cite{basin2009model}. La formalización de propiedades de seguridad como autorización, autenticación, integridad y confidencialidad utilizando VDM-SL, el precursor de VDM++, ha demostrado la capacidad de estos métodos para especificar sistemas sin ambigüedades \cite{steer2003specifying}.

En el ámbito de los sistemas de tiempo real, donde las restricciones temporales son tan importantes como la corrección lógica, UPPAAL es la herramienta de referencia \cite{larsen1997uppaal}. Se ha aplicado con éxito para verificar sistemas críticos como los controladores de semáforos inteligentes, donde un fallo en la temporización puede tener consecuencias catastróficas \cite{bengtsson1996verification}. Su capacidad para modelar y verificar protocolos con restricciones de tiempo también lo hace adecuado para analizar aspectos temporales en las políticas de control de acceso, como las definidas en el modelo \textit{Temporal Role-Based Access Control} (TRBAC) \cite{bertino1998trbac}.

Este trabajo se distingue por su enfoque metodológico integral: no solo se especifica el sistema de control de acceso en VDM++, sino que se valida su lógica interna con análisis de cobertura y, crucialmente, se verifica formalmente con un doble enfoque de \textit{model checking}. Se utiliza NuSMV para probar la robustez de las políticas de seguridad desde una perspectiva lógica y atemporal, y UPPAAL para garantizar que el comportamiento del sistema cumple con las restricciones de tiempo del mundo real. Esta combinación de técnicas proporciona un nivel de confianza en la correctitud del sistema que es difícil de alcanzar con un único método.
% -----------------------------------------------------------
% 2) OBJETIVOS
% -----------------------------------------------------------
\section{Objetivos}
\subsection{Objetivo General} Elaborar la especificación formal de un sistema de control de acceso para los nuevos laboratorios de la Universidad La Salle, que garantice la seguridad y la trazabilidad desde su puesta en marcha, y que sirva como modelo base escalable para otras instituciones de educación superior.

\subsection{Objetivos Específicos} \begin{enumerate} \item Modelar las entidades clave del sistema: Usuarios, Laboratorios y Permisos de acceso. \item Especificar las políticas y reglas de acceso mediante un método formal para lograr la precisión necesaria en el diseño. \item Definir las operaciones críticas (como la verificación de acceso y gestión de permisos) y establecer los invariantes del sistema para asegurar su consistencia lógica. \end{enumerate}
% Enumerar objetivos generales y específicos
% Ejemplo:
% \subsection{Objetivo General}
% Desarrollar un sistema que permita...
% \subsection{Objetivos Específicos}
% \begin{enumerate}
%   \item Analizar los factores que afectan...
%   \item Implementar un prototipo de...
%   \item Evaluar los resultados mediante...
% \end{enumerate}

\section{Marco teórico}

\subsection{Definición de Verificación Formal}
La verificación formal es una disciplina de la ingeniería de software y hardware que utiliza métodos matemáticos para demostrar que un sistema cumple con un conjunto de propiedades o especificaciones formales \cite{baier2008principles}. A diferencia de las pruebas (\textit{testing}), que solo pueden encontrar errores mediante la ejecución de un subconjunto de casos, la verificación formal tiene como objetivo probar la ausencia de ciertos tipos de errores en todos los comportamientos posibles del sistema \cite{clarke1999model}.

Este proceso requiere tres componentes clave: un lenguaje formal con una semántica matemática precisa para describir el sistema, una especificación de las propiedades que el sistema debe cumplir, y un método de verificación (como el \textit{model checking} o la demostración de teoremas) para probar que la descripción del sistema satisface la especificación \cite{baier2008principles}.

\subsection{VDM++}

\subsubsection{Definición}
VDM++ es un lenguaje de especificación formal orientado a objetos y basado en modelos, que evolucionó a partir de VDM-SL (\textit{Specification Language}). Es especialmente adecuado para modelar sistemas complejos y con estado, describiendo el sistema en términos de los tipos de datos que maneja y las operaciones que modifican su estado \cite{fitzgerald2005validated}.

\subsubsection{Clases}
Un modelo en VDM++ se estructura como un conjunto de clases, que encapsulan un estado interno (variables de instancia) y el comportamiento que opera sobre ese estado (operaciones y funciones) \cite{fitzgerald2005validated}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Estructura_de_una_clase_en_VDM++.png} 
    \caption{Estructura de una clase en VDM++.} 
    \label{fig:estructura_vdm} 
\end{figure}

\subsubsection{Tipos}
VDM++ posee un sistema de tipos robusto, que incluye tipos básicos como \texttt{nat} (números naturales), \texttt{bool} (booleanos) e \texttt{int} (enteros), así como tipos compuestos potentes como \texttt{set of} (conjuntos), \texttt{seq of} (secuencias) y \texttt{map to} (mapeos), que son fundamentales para modelar estructuras de datos complejas \cite{vdmstandard}.

\subsubsection{Invariantes}
Una invariante de clase es una condición o predicado lógico sobre las variables de instancia que debe ser verdadero en todo momento (excepto durante la ejecución de una operación). Las invariantes son cruciales para definir la consistencia y la integridad de los datos del modelo \cite{fitzgerald2005validated}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Especificacion_de_una_invariante.png} 
    \caption{Especificación de una invariante.} 
    \label{fig:invariante} 
\end{figure}

\subsubsection{Pre y Postcondiciones}
Las operaciones pueden ser especificadas mediante pre y postcondiciones. Una precondición es un predicado que debe cumplirse antes de que una operación pueda ser invocada. Una postcondición es un predicado que la operación garantiza que se cumplirá al finalizar, relacionando el estado final con el estado inicial. Juntas, forman un "contrato" que define el comportamiento de la operación \cite{fitzgerald2005validated}.

\subsubsection{Funciones y Operaciones}
VDM++ distingue entre \textit{operations}, que pueden modificar el estado de una clase (tienen efectos secundarios), y \textit{functions}, que son puramente computacionales y no pueden cambiar el estado \cite{fitzgerald2005validated}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Especificacion_de_una_invariante_y_una_funcion.png} 
    \caption{Especificación de una función y una función invariante.} 
    \label{fig:funcion_invariante} 
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Especificacion_de_una_operacion.png} 
    \caption{Especificación de operaciones.} 
    \label{fig:operaciones} 
\end{figure}

\subsubsection{Herramienta (VDM++ Toolbox)}
Es un Entorno de Desarrollo Integrado (IDE) para VDM++. Proporciona herramientas para el análisis sintáctico y de tipos, un intérprete para ejecutar y depurar la especificación, un generador de pruebas y una herramienta de análisis de cobertura de código, que es esencial para la validación del modelo \cite{fitzgerald2005validated}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Interfaces_de_VDM++_Toolbox.png} 
    \caption{Interface de VDM++ Toolbox.} 
    \label{fig:interface_toolbox} 
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Interprete_de_VDM++_Toolbox.png} 
    \caption{Interprete de VDM++ Toolbox.} 
    \label{fig:interprete_toolbox} 
\end{figure}

\subsection{Model Checking}
El \textit{Model Checking} es una técnica de verificación formal automatizada que explora sistemáticamente todos los estados posibles de un sistema (su espacio de estados) para determinar si cumple una propiedad dada \cite{clarke1999model}. Las propiedades se expresan formalmente utilizando lógicas temporales, como la Lógica de Árbol Computacional (CTL) o la Lógica de Tiempo Lineal (LTL). Si el sistema no cumple una propiedad, la herramienta genera un contraejemplo: una traza de ejecución que demuestra cómo se viola la propiedad \cite{baier2008principles}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Ejemplo_Model_Checking.png} 
    \caption{Ejemplo Model Checking.} 
    \label{fig:ejemplo_model_checking} 
\end{figure}

\subsubsection{NuSMV}
Es un \textit{symbolic model checker} que utiliza estructuras de datos eficientes como los Diagramas de Decisión Binarios (BDDs) para representar el espacio de estados de forma compacta, lo que le permite analizar sistemas muy grandes \cite{cimatti2002nusmv}. Es ideal para verificar propiedades lógicas y de seguridad (\textit{safety properties}, como "un estado inseguro nunca es alcanzable") y de vivacidad (\textit{liveness properties}, como "una petición siempre será atendida eventualmente") sobre sistemas que no tienen un componente de tiempo real explícito.

\subsubsection{UPPAAL}
Es una caja de herramientas integrada para la modelización, simulación y verificación de sistemas de tiempo real. El modelo de un sistema en UPPAAL es una red de autómatas temporizados, que son autómatas de estados finitos extendidos con variables de reloj de valor real \cite{behrmann2004tutorial}. Las transiciones pueden tener guardas (condiciones sobre los relojes que deben cumplirse para que la transición ocurra) y los estados pueden tener invariantes (condiciones sobre los relojes que deben cumplirse para permanecer en el estado). UPPAAL es ideal para verificar propiedades que incluyen restricciones de tiempo \cite{larsen1997uppaal}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Ejemplo_de_UPPAAL.png} 
    \caption{Ejemplo de UPPAAL, sistema modelado con 5 estados.} 
    \label{fig:ejemplo_uppaal} 
\end{figure}

% -----------------------------------------------------------
% 3) METODOLOGÍA
% -----------------------------------------------------------
\section{Metodología}
La metodología empleada en este trabajo es de naturaleza computacional y formal, basada en el ciclo de vida de desarrollo de software riguroso para sistemas críticos. El proceso se centra en la transformación sistemática de requerimientos informales en especificaciones matemáticas precisas, permitiendo la detección temprana de ambigüedades y errores lógicos.

El desarrollo del proyecto se ha estructurado en cuatro etapas secuenciales e iterativas, tal como se ilustra en el diagrama de flujo de la Fig. \ref{fig:metodologia}, y se detalla a continuación:

\subsection{Análisis y Abstracción de Requerimientos}
En esta etapa inicial se realizó la recopilación de datos mediante la observación de los procesos actuales de acceso en los laboratorios de la Universidad La Salle. Se identificaron los actores (estudiantes, docentes, administrativos), los recursos (laboratorios) y las restricciones operativas.
\begin{itemize}
    \item \textbf{Entrada:} Reglas de negocio en lenguaje natural y entrevistas con los responsables de laboratorio.
    \item \textbf{Salida:} Lista refinada de Requerimientos Funcionales (RF) y un Diagrama de Clases UML preliminar.
\end{itemize}

\subsection{Especificación Formal con VDM++}
Esta fase constituye el núcleo del modelado teórico. Se procedió a la formalización de la estructura estática y dinámica del sistema utilizando el lenguaje \textit{Vienna Development Method} orientado a objetos (VDM++). Se definieron tres componentes matemáticos clave:
\begin{enumerate}
    \item \textbf{Tipos de Datos:} Abstracción de entidades mediante \texttt{types} personalizados.
    \item \textbf{Invariantes de Estado:} Ecuaciones lógicas que restringen los valores permitidos de las variables de instancia para mantener la integridad del sistema.
\end{enumerate}

\subsection{Validación Interna y Análisis de Cobertura}
Para garantizar la consistencia interna del modelo, se empleó una metodología experimental de pruebas basadas en escenarios. Utilizando la herramienta \textit{VDM++ Toolbox}.

El criterio de éxito establecido fue alcanzar un 100\% de cobertura de código (\textit{statement coverage}), asegurando que todas las líneas de la especificación, incluyendo las cláusulas de manejo de excepciones, fueran ejercitadas durante la simulación.

\subsection{Verificación de Modelos (Model Checking)}
Finalmente, se realizó la verificación externa de propiedades críticas mediante técnicas de \textit{Model Checking}, dividiendo el análisis en dos dominios complementarios:

\subsubsection{Seguridad Lógica (NuSMV)}
Se tradujo el modelo a una máquina de estados finitos para verificar propiedades de seguridad (\textit{safety properties}) expresadas en Lógica de Árbol Computacional (CTL), asegurando matemáticamente que nunca ocurra un estado prohibido.

\subsubsection{Tiempo Real (UPPAAL)}
Se modeló el sistema como una red de autómatas temporizados para validar restricciones temporales (\textit{liveness properties}), verificando que el sistema responda a las solicitudes de acceso dentro de los plazos establecidos (latencia máxima permitida).

\begin{figure}[H]
    \centering
    \includegraphics[width=2.5in]{Imagenes/diagrama_metodologia.png}    
    \caption{Diagrama de flujo de la metodología}
    \label{fig:metodologia}
\end{figure}
% Explicar la metodología empleada: experimental, teórica, computacional, etc.
% Se puede usar diagramas de flujo, pseudocódigo, ecuaciones.
% Ejemplo:
% El proceso sigue tres etapas principales: (i) recopilación de datos, (ii) procesamiento, y (iii) análisis de resultados.
% \begin{figure}[!t]
%   \centering
%   \includegraphics[width=2.5in]{metodologia_diagrama}
%   \caption{Diagrama de flujo de la metodología}
%   \label{fig:metodologia}
% \end{figure}

% -----------------------------------------------------------
% 4) DESARROLLO / IMPLEMENTACIÓN
% -----------------------------------------------------------
\section{Desarrollo}
% Descripción detallada de la implementación o desarrollo del proyecto.
% Se pueden incluir subsecciones, ecuaciones, figuras, algoritmos.
% Ejemplo:
% \subsection{Arquitectura del sistema}
% \begin{figure}[!t]
%   \centering
%   \includegraphics[width=2.5in]{arquitectura}
%   \caption{Arquitectura propuesta}
%   \label{fig:arquitectura}
% \end{figure}
%
% \subsection{Algoritmo principal}
% \begin{algorithm}[H]
%   \caption{Algoritmo de procesamiento de datos}
%   \begin{algorithmic}
%     \STATE Inicializar parámetros
%     \STATE Ejecutar ciclo principal
%     \STATE Retornar resultados
%   \end{algorithmic}
% \end{algorithm}

% -----------------------------------------------------------
En esta sección se detalla la aplicación práctica de la metodología formal al diseño y verificación del Sistema de Control de Acceso para Laboratorios (SICA-L).

\subsection{Planteamiento del problema}
La Universidad La Salle de Arequipa se encuentra en un proceso de expansión de su infraestructura académica, dotando a nuevos laboratorios con equipos de alto valor, tecnología de punta y materiales de investigación sensibles. En este contexto, la ausencia de un sistema de control de acceso formal y robusto constituye una vulnerabilidad crítica. Los métodos tradicionales, como las bitácoras manuales, son insuficientes para este entorno, ya que son propensos a errores humanos, falsificación y carecen de capacidades de auditoría en tiempo real.

La falta de un sistema adecuado genera riesgos directos y significativos:
\begin{itemize}
    \item \textbf{Riesgo de Seguridad:} Facilita el posible robo, daño o mal uso de equipos costosos, comprometiendo la inversión institucional.
    \item \textbf{Riesgo de Integridad Académica:} Permite la manipulación no autorizada de experimentos o datos de investigación.
    \item \textbf{Falta de Trazabilidad:} Impide determinar con certeza quién se encontraba en las instalaciones durante un incidente, dificultando la rendición de cuentas.
\end{itemize}

Dado que el sistema aún no existe, la universidad tiene la oportunidad única de diseñar e implementar una solución correcta desde su concepción, un enfoque conocido como \textit{greenfield}.

\subsection{Solución propuesta}
Se propone el diseño de un Sistema de Control de Acceso (SICA-L) desarrollado íntegramente mediante métodos formales. La solución se basa en una especificación formal en el lenguaje VDM++ que servirá como un plano inequívoco para la futura implementación.

Este modelo no solo se valida para asegurar su consistencia lógica interna, sino que también se somete a un riguroso proceso de verificación formal utilizando una doble estrategia de \textit{model checking}:
\begin{itemize}
    \item \textbf{Verificación de Propiedades de Seguridad:} Se utilizará NuSMV para demostrar matemáticamente que el sistema es inmune a vulnerabilidades lógicas, como la concesión de acceso indebido.
    \item \textbf{Verificación de Propiedades de Tiempo Real:} Se empleará UPPAAL para garantizar que el sistema responde dentro de las restricciones temporales requeridas para una interacción fluida y segura en el mundo real.
\end{itemize}

\subsection{Requerimientos}
A partir del problema, se han identificado los siguientes requerimientos funcionales:
\begin{itemize}
    \item \textbf{RF1:} Registrar, modificar y dar de baja usuarios con identificador institucional único.
    \item \textbf{RF2:} Asignar y revocar permisos de acceso a uno o varios laboratorios.
    \item \textbf{RF3:} Procesar solicitudes de acceso, verificando identidad y autorización.
    \item \textbf{RF4:} Registrar de manera inmutable todos los intentos de acceso (\textit{audit trail}).
    \item \textbf{RF5:} Registrar formalmente la entrada y salida de los usuarios autorizados.
\end{itemize}

\subsection{Diagrama de clases}
El primer paso del modelado es definir la estructura estática del sistema. El diagrama de clases UML muestra las entidades principales del SICA-L (Usuario, Laboratorio, Evento) y la clase central \texttt{SistemaControlAcceso} que orquesta las interacciones entre ellas.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/DiagramaClases.png}
    \caption{Diagrama de Clases UML del Sistema SICA-L.}
    \label{fig:diagrama_clases}
\end{figure}

\subsection{Modelo en VDM}
La estructura definida en el diagrama de clases se traduce a una especificación formal en VDM++. Se utilizan tipos de datos como \texttt{set of} para gestionar las colecciones de usuarios y laboratorios, y \texttt{map nat1 to set of nat1} para representar la matriz de permisos. Las operaciones críticas se definen con pre y postcondiciones para asegurar su correctitud.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte1.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 1.}
    \label{fig:vdm_parte1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte2.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 2.}
    \label{fig:vdm_parte2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte3.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 3.}
    \label{fig:vdm_parte3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte4.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 4.}
    \label{fig:vdm_parte4}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseEvento.png}
    \caption{Especificación VDM++ de la clase Evento.}
    \label{fig:vdm_evento}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseLaboratorio.png}
    \caption{Especificación VDM++ de la clase Laboratorio.}
    \label{fig:vdm_laboratorio}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseUsuario.png}
    \caption{Especificación VDM++ de la clase Usuario.}
    \label{fig:vdm_usuario}
\end{figure}

\subsection{Análisis de cobertura}
La validación del modelo se realizó a través del intérprete de comandos de \textit{VDM++ Toolbox}. Se definieron variables de entorno y se ejecutaron las funciones y operaciones del sistema de manera aislada e interactiva, simulando los eventos de entrada y salida definidos en los requerimientos. Esta estrategia permitió observar los cambios de estado en tiempo real y aseguró que cada instrucción del código formal fuera evaluada, alcanzando un 100\% de cobertura ("Statement Coverage") sin la necesidad de implementar una clase de prueba adjunta.

\lstinputlisting[style=codigo, language=]{AnalisisCobertura.txt}
\clearpage

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/Coverage100.png}
    \caption{Reporte de Cobertura del 100\% generado por VDM++ Toolbox.}
    \label{fig:cobertura_vdm}
\end{figure}

\subsection{Modelo en NuSMV}
Para la verificación formal de las políticas de seguridad, el modelo VDM++ se abstrajo a un modelo de estados finitos en NuSMV. Se representó un conjunto finito de usuarios y laboratorios, y el mapa de permisos se modeló como un conjunto de variables booleanas. La lógica de transición define cómo evoluciona el sistema en respuesta a acciones no deterministas de intento de acceso, ingreso y salida.

\lstinputlisting[style=codigo, language=]{SICA-L.smv}
\clearpage

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/resultado NuSMV.png}
    \caption{Resultado de la verificación en NuSMV.}
    \label{fig:nusmv}
\end{figure}

\subsection{Modelo del Usuario en UPPAAL}
Para representar el comportamiento individual de los actores en el sistema, se diseñó una plantilla de autómata denominada \texttt{Usuario}. Este modelo es paramétrico y recibe como constantes de inicialización un identificador único (\texttt{uid}) y un indicador binario de autorización (\texttt{permiso}), el cual determina la capacidad del usuario para acceder al recurso protegido.

Estructuralmente, el autómata se define como una máquina de estados finita cíclica compuesta por cuatro localizaciones lógicas:
\begin{itemize}
    \item \textbf{\texttt{idle}:} Representa el estado inicial de reposo o inactividad del usuario.
    \item \textbf{\texttt{Intento}:} Modela la fase transitoria en la que el usuario solicita el ingreso al sistema.
    \item \textbf{\texttt{Dentro}:} Estado que simboliza la permanencia exitosa del usuario dentro del área o recurso restringido, accesible tras la validación del permiso.
    \item \textbf{\texttt{Saliendo}:} Fase de terminación de la sesión antes de retornar al estado de reposo.
\end{itemize}

Las transiciones del modelo simulan el flujo secuencial de autenticación y uso, donde el avance entre los estados \texttt{Intento} y \texttt{Dentro} está condicionado por las guardas lógicas asociadas a la variable de configuración \texttt{permiso}.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/Modelo_de_Automata_UPPAAL.png}
    \caption{Modelo de Autómata Estudiante.}
    \label{fig:modelo_uppaal}
\end{figure}

% 5) RESULTADOS
% -----------------------------------------------------------
% -----------------------------------------------------------
% 5) RESULTADOS
% -----------------------------------------------------------
\section{Resultados}
Los resultados obtenidos tras la aplicación de la metodología formal se presentan en tres niveles de validación: consistencia sintáctica, verificación de propiedades de seguridad y validación temporal.

\subsection{Validación de la Especificación en VDM++}
El modelo estático y dinámico fue sometido a un análisis de sintaxis y tipos utilizando \textit{VDM++ Toolbox}. La ejecución de los casos de prueba definidos cubrió la totalidad de las operaciones del sistema (\texttt{RegistrarIngreso}, \texttt{VerificarPermiso}, etc.).
Como se evidencia en la Fig. \ref{fig:cobertura_vdm}, el análisis de cobertura reportó un 100\% de \textit{statement coverage}. Esto indica que:
\begin{enumerate}
    \item No existen porciones de código muerto o inalcanzable en la especificación.
    \item Todas las cláusulas de precondición y postcondición fueron evaluadas al menos una vez sin generar violaciones de invariantes.
    \item La lógica de manejo de tipos compuestos (mapas y conjuntos) es consistente.
\end{enumerate}

\subsection{Verificación Formal con NuSMV}
La traducción del modelo a lógica simbólica permitió verificar propiedades críticas de seguridad (\textit{Safety Properties}). Al ejecutar el \textit{model checker} NuSMV sobre el archivo \texttt{.smv} generado, se obtuvieron los siguientes resultados para las especificaciones CTL:

\begin{itemize}
    \item \textbf{Propiedad de Seguridad:} \texttt{SPEC AG !((permiso = 0) \& (estado = DENTRO))} \\
    \textit{Resultado:} \textbf{TRUE}.
    Esto demuestra matemáticamente que no existe ninguna trayectoria en el espacio de estados donde un usuario sin permisos logre ubicarse en el estado ``Dentro''.
    
    \item \textbf{Propiedad de Vivacidad:} \texttt{SPEC AG ((estado = INTENTO) -> AF (estado = DENTRO | estado = IDLE))} \\
    \textit{Resultado:} \textbf{TRUE}.
    Se verifica que el sistema no entra en \textit{deadlock} (bloqueo); todo intento de acceso es eventualmente resuelto, ya sea permitiendo el paso o rechazándolo.
\end{itemize}

% -----------------------------------------------------------
% 6) DISCUSIÓN
% -----------------------------------------------------------
\section{Discusión}
La aplicación de métodos formales en el diseño del sistema SICA-L ha permitido identificar y corregir ambigüedades que tradicionalmente pasan desapercibidas en el desarrollo de software convencional. Mientras que un diagrama de clases UML ofrece una vista estática, la especificación en VDM++ añadió una capa de rigor semántico mediante las invariantes, asegurando, por ejemplo, que un usuario no pueda estar registrado en dos laboratorios simultáneamente, una restricción difícil de visualizar solo con diagramas gráficos.

Los resultados de NuSMV son particularmente significativos. A diferencia de las pruebas de software (\textit{testing}), que solo demuestran la presencia de errores, el resultado \texttt{TRUE} en las fórmulas CTL demuestra la ausencia de los mismos respecto a las propiedades especificadas. Esto otorga al sistema SICA-L un nivel de confiabilidad de grado industrial, superior a los sistemas de control de acceso comerciales estándar basados únicamente en bases de datos relacionales sin validación formal.

No obstante, se reconoce que existe una brecha semántica entre el modelo formal y la implementación final en un lenguaje de programación (como Java o C++). Por tanto, este trabajo sirve como un \textit{blueprint} verificado, pero la implementación física requerirá pruebas de integración adicionales para asegurar que el código final respete fielmente las restricciones del modelo.

% -----------------------------------------------------------
% 7) CONCLUSIONES
% -----------------------------------------------------------
\section{Conclusiones}
El desarrollo del proyecto permite concluir lo siguiente en relación con los objetivos planteados:

\begin{enumerate}
    \item Se logró modelar exitosamente las entidades críticas (Usuarios, Laboratorios y Sistema) utilizando VDM++, creando una abstracción precisa que encapsula tanto los datos como el comportamiento, superando las limitaciones de los modelos de datos tradicionales.
    
    \item La especificación de las políticas de acceso mediante invariantes y contratos (pre/post condiciones) ha demostrado ser efectiva. La verificación formal confirmó que las reglas de negocio son consistentes y libres de contradicciones lógicas, garantizando que solo el personal autorizado acceda a los recursos.
    
    \item La definición y validación de las operaciones críticas mediante \textit{Model Checking} (NuSMV y UPPAAL) aseguró la corrección del sistema. Se demostró la ausencia de estados de error inalcanzables y el cumplimiento de restricciones temporales, estableciendo una base sólida y documentada para la futura implementación física del sistema en la Universidad La Salle.
\end{enumerate}

Como trabajo futuro, se propone la generación automática de código a partir del modelo VDM++ verificado y la integración con dispositivos físicos de lectura biométrica o RFID para validar el modelo en un entorno de producción real.

% -----------------------------------------------------------
% 8) AGRADECIMIENTOS
% -----------------------------------------------------------
\section*{Agradecimientos}
Agradecemos especialmente al Mg. José Peñaloza, docente del curso de Comunicación II, por su valiosa orientación en la estructuración y revisión del presente artículo, lo cual contribuyó significativamente a la calidad divulgativa de esta investigación presentada en la feria \textit{Inspira La Salle 2025}.
% =========================================================================
% APPENDIX / APÉNDICE
% =========================================================================
% Si tienes un solo apéndice:
%\appendix[Nombre del Apéndice]
% - Aquí se incluyen materiales adicionales que complementan el cuerpo principal:
%   Ejemplos: demostraciones matemáticas, cálculos extensos, detalles de algoritmos,
%   tablas de datos completas, pruebas técnicas, derivaciones largas, código fuente, etc.
% - Usar \section*{Título} para secciones internas si es necesario.
% - No usar \section normal después de \appendix.
%
% Ejemplo:

% Si tienes múltiples apéndices:
% \appendices
% \section{Apéndice A: Algoritmos Completos}
% Texto completo del algoritmo que se resumió en el artículo.
% \section{Apéndice B: Datos Experimentales}
% Tablas y resultados completos de experimentos o simulaciones.
% \section{Apéndice C: Material Complementario}
% Cualquier otra información que sea relevante pero demasiado extensa para incluir
% en el cuerpo principal del artículo.

% =========================================================================
% REFERENCIAS / BIBLIOGRAFÍA
% =========================================================================
% 1) Usando BibTeX (recomendado):
% - Mantener archivo .bib con todas las referencias.
%para mostrar todas las referencias si es que no se citaron
\begin{thebibliography}{00}

\bibitem{bryans2008formal}
J. Bryans, J. Fitzgerald, H. C. B. Oliveira, and P. V. Thaviero, ``Formal engineering of XACML access control policies,'' in \textit{Proc. 10th Int. Conf. Formal Eng. Methods (ICFEM)}, Kitakyushu, Japan, 2008, pp. 37--56.

\bibitem{mukherjee1997computer}
P. Mukherjee, ``Computer-aided validation of a defensive aids system specification,'' \textit{IEE Proceedings - Software}, vol. 144, no. 4, pp. 182--188, Aug. 1997.

\bibitem{stephens1996mondex}
K. Stephens and P. Sutton, ``The Mondex Electronic Purse,'' in \textit{Formal Methods for Industrial Applications}, vol. 1165, Lecture Notes in Computer Science, Berlin: Springer, 1996, pp. 50--63.

\bibitem{clarke2018model}
E. M. Clarke, T. A. Henzinger, H. Veith, and R. Bloem, \textit{Handbook of Model Checking}. Cham: Springer, 2018.

\bibitem{lowe1996breaking}
G. Lowe, ``Breaking and fixing the Needham-Schroeder Public-Key Protocol using FDR,'' in \textit{Tools and Algorithms for the Construction and Analysis of Systems}, vol. 1055, Lecture Notes in Computer Science, Berlin: Springer, 1996, pp. 147--166.

\bibitem{basin2009model}
D. Basin, J. Doser, and T. Lodderstedt, ``Model driven security: From UML models to access control architectures,'' \textit{ACM Trans. Softw. Eng. Methodol.}, vol. 15, no. 1, pp. 39--91, 2006.

\bibitem{steer2003specifying}
K. Steer, ``Specifying security properties in VDM-SL,'' in \textit{Proc. 1st Overture Workshop}, 2003.

\bibitem{larsen1997uppaal}
K. G. Larsen, P. Pettersson, and W. Yi, ``UPPAAL in a nutshell,'' \textit{Int. J. Softw. Tools Technol. Transf.}, vol. 1, no. 1-2, pp. 134--152, 1997.

\bibitem{bengtsson1996verification}
J. Bengtsson, K. G. Larsen, F. Larsson, P. Pettersson, and W. Yi, ``UPPAAL: a tool suite for automatic verification of real-time systems,'' in \textit{Hybrid Systems III}, vol. 1066, Lecture Notes in Computer Science, Springer, 1996, pp. 232--243.

\bibitem{bertino1998trbac}
E. Bertino, C. Bettini, E. Ferrari, and P. Samarati, ``An access control model supporting periodicity constraints and temporal reasoning,'' \textit{ACM Trans. Database Syst.}, vol. 23, no. 3, pp. 231--285, 1998.

% Referencia general sobre Model Checking (La Biblia del tema)
\bibitem{baier2008principles}
C. Baier and J.-P. Katoen, \textit{Principles of Model Checking}. Cambridge, MA, USA: MIT Press, 2008.

% Referencia clásica de Clarke (Padre del Model Checking)
\bibitem{clarke1999model}
E. M. Clarke, O. Grumberg, and D. A. Peled, \textit{Model Checking}. Cambridge, MA, USA: MIT Press, 1999.

% Referencia principal de VDM++ (El libro estándar)
\bibitem{fitzgerald2005validated}
J. Fitzgerald, P. G. Larsen, P. Mukherjee, N. Plat, and M. Verhoef, \textit{Validated Designs for Object-oriented Systems}. London, UK: Springer-Verlag, 2005.

% Estándar ISO de VDM (Para los tipos de datos)
\bibitem{vdmstandard}
\textit{Information technology -- Programming languages, their environments and system software interfaces -- Vienna Development Method -- Specification Language -- Part 1: Base language}, ISO/IEC 13817-1, International Organization for Standardization, Dec. 1996.

% Referencia principal de NuSMV
\bibitem{cimatti2002nusmv}
A. Cimatti, E. Clarke, E. Giunchiglia, F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani, and A. Tacchella, ``NuSMV 2: An opensource tool for symbolic model checking,'' in \textit{Computer Aided Verification (CAV 2002)}, E. Brinksma and K. G. Larsen, Eds. Berlin, Heidelberg: Springer, 2002, pp. 359--364.

% Referencia tutorial de UPPAAL
\bibitem{behrmann2004tutorial}
G. Behrmann, A. David, and K. G. Larsen, ``A tutorial on Uppaal,'' in \textit{Formal Methods for the Design of Real-Time Systems}, M. Bernardo and F. Corradini, Eds. Berlin, Heidelberg: Springer, 2004, pp. 200--236.

% Referencia clásica de UPPAAL (In a nutshell)
\bibitem{larsen1997uppaal}
K. G. Larsen, P. Pettersson, and W. Yi, ``UPPAAL in a nutshell,'' \textit{International Journal on Software Tools for Technology Transfer}, vol. 1, no. 1-2, pp. 134--152, 1997.

\end{thebibliography}

%
% 2) Manualmente:
% - Usar entorno thebibliography si no se usa BibTeX.
% - Cada referencia se declara con \bibitem{clave} y luego se cita con \cite{clave}.
% - Mantener consistencia en nombres de autores, títulos, volúmenes, páginas, URLs y DOI.
%
% Ejemplos de referencias:
% \begin{thebibliography}{9}
% \bibitem{ref1} Autor, "Título del artículo," Revista, vol., no., pp., año.
% \bibitem{ref2} Autor, "Título," Libro, Editorial, año.
% \bibitem{ref3} Autor, "Título en línea," [Online]. Available: URL, año.
% \end{thebibliography}
%
% Notas importantes:
% - Incluir DOI si está disponible.
% - Para artículos en línea, poner [Online] y la URL.
% - Mantener formato consistente con IEEE (mayúsculas, minúsculas, comas, puntos).

\newpage

\end{document}

% =========================================================================
% IEEE LaTeX Quick Guide – Comentarios y Ejemplos
% =========================================================================

% 1) SECCIONES
% - Numeración recomendada:
%   Primarias: números romanos      -> \section{Introduction}
%   Secundarias: letras mayúsculas  -> \subsection{Related Work}
%   Terciarias: números arábigos    -> \subsubsection{Algorithm Details}
%   Cuaternarias: letras minúsculas -> usar si es necesario
% - Reference y Acknowledgment no se numeran.
% Ejemplo:
% \section{Introduction}
% \subsection{Motivation}
% \subsubsection{Previous Work}

% 2) CITAS
% - Usar \cite{} para referencias
% - Múltiples referencias: \cite{ref1,ref2,ref3}
% Ejemplo:
% Como se muestra en \cite{ref1,ref2}, los resultados son consistentes.

% 3) LISTAS
% a) Sin numeración
% \begin{list}{}{}
%   \item Elemento A
%   \item Elemento B
% \end{list}
% b) Numeradas
% \begin{enumerate}
%   \item Primer punto
%   \item Segundo punto
% \end{enumerate}
% c) Con viñetas
% \begin{itemize}
%   \item Punto 1
%   \item Punto 2
% \end{itemize}

% 4) FIGURAS
% - Caption después de la imagen
% - Label después del caption
% - Ejemplo:
% \begin{figure}[!t]
%   \centering
%   \includegraphics[width=2.5in]{fig1}
%   \caption{Resultados de la simulación}
%   \label{fig:sim}
% \end{figure}
% - Figuras dobles con subfiguras:
% \begin{figure*}[!t]
%   \centering
%   \subfloat[]{\includegraphics[width=2.5in]{fig1}\label{fig:first}}
%   \hfil
%   \subfloat[]{\includegraphics[width=2.5in]{fig2}\label{fig:second}}
%   \caption{(a) Caso 1 (b) Caso 2}
%   \label{fig:double}
% \end{figure*}

% 5) TABLAS
% - Caption antes de la tabla
% - Fuente: footnotesize
% - Label después del caption
% - Ejemplo:
% \begin{table}[!t]
%   \caption{Ejemplo de tabla}
%   \centering
%   \begin{tabular}{|c|c|}
%     \hline
%     A & B \\ \hline
%     1 & 2 \\ \hline
%   \end{tabular}
%   \label{tab:example}
% \end{table}

% 6) ALGORITMOS
% - Numerados y con título
% - Separados por líneas horizontales
% - Ejemplo:
% \begin{algorithm}[H]
%   \caption{Algoritmo de ejemplo}
%   \begin{algorithmic}
%     \STATE Inicializar variables
%     \STATE Ejecutar proceso
%     \STATE Retornar resultados
%   \end{algorithmic}
% \end{algorithm}

% 7) ECUACIONES
% - Numeración consecutiva: (1), (2), (3)…
% - No usar guiones ni puntos: (1a) en vez de (1-a)
% - Referencias con \ref{}: (\ref{eq:example})
% - Multi-línea: usar align o multline
% - Subequaciones: subequations
% Ejemplo simple:
% \begin{equation}
%   x = \sum_{i=0}^{n} 2i Q
%   \label{eq:example}
% \end{equation}
% Ejemplo multi-línea:
% \begin{align}
%   a &= b + c \\
%   d &= e + f
% \end{align}
% Subequaciones:
% \begin{subequations}\label{eq:sub}
%   \begin{align}
%     f &= g \\
%     f' &= g'
%   \end{align}
% \end{subequations}

% 8) MATRICES Y ARRAYS
% - Matrices: matrix, pmatrix, bmatrix, Bmatrix, vmatrix, Vmatrix
% - Arrays: personalizar alineación con c, r, l y reglas verticales "|"
% Ejemplo:
% \begin{equation}
%   \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}
% \end{equation}
% \begin{equation}
%   \left(\begin{array}{c|c} a & b \\ \hline c & d \end{array}\right)
% \end{equation}

% 9) ESTRUCTURAS DE CASOS
% - Usar el entorno cases
% - "&" para alinear columnas
% Ejemplo:
% \begin{equation*}
%   z_m(t) = 
%   \begin{cases}
%     1,& \text{si } \beta_m(t)\\
%     0,& \text{en otro caso}
%   \end{cases}
% \end{equation*}

% 10) FUNCIONES EN ECUACIONES
% - Funciones comunes: \sin, \max, \argmin
% - Funciones personalizadas: \text{}
% Ejemplo:
% \begin{equation*}
%   d_R^{KM} = \underset{d_l^{KM}}{\text{arg min}}\{d_1^{KM},...,d_6^{KM}\}
% \end{equation*}

% 11) ACRÓNIMOS EN ECUACIONES
% - Usar \text{} para mantener consistencia con el texto
% Ejemplo:
% \begin{equation*}
%   \text{MSE} = \frac{1}{n}\sum_{i=1}^{n}(Y_i - \hat{Y}_i)^2
% \end{equation*}

