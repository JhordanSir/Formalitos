\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{amsmath,amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{array}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\usepackage{textcomp}
\usepackage[spanish,es-tabla]{babel} 
\usepackage{stfloats}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cite}
\usepackage{xcolor}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{listings}
\hyphenation{op-tical net-works semi-conduc-tor IEEE-Xplore}
% updated with editorial comments 8/9/2021
\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}

\lstdefinestyle{codigo}{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\footnotesize,
    frame=single,
    breaklines=true,
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{orange!80!black},
    showstringspaces=false
}
% Headers con fancyhdr
\usepackage{fancyhdr}

% --- Estilo general ---
\fancypagestyle{otherpages}{%
  \fancyhf{}
  \fancyhead[C]{\textbf{Universidad La Salle - Inspira La Salle 2025}}
  \fancyhead[R]{\thepage}
  \renewcommand{\headrulewidth}{0.4pt}
}

\begin{document}

% Aplica estilo
\pagestyle{otherpages}

\title{Especificación Formal de un Sistema de Control de Acceso para Laboratorios en la Universidad La Salle de Arequipa%
\thanks{Presentado en la Feria de Proyectos \textit{Inspira La Salle}, Universidad La Salle, Arequipa, 2025}}

\author{
    \IEEEauthorblockN{
        Jhordan Huamaní Huamaní\textsuperscript{1},
        Jorge Ortiz Castañeda\textsuperscript{1},
        José Mamani Zuñiga\textsuperscript{1},
        Miguel Flores León\textsuperscript{1}
    }
    \IEEEauthorblockA{
        \textsuperscript{1}Departamento de Ingeniería de Software, Universidad La Salle de Arequipa, Perú \\
        \{jhordanhh, jortizc, jmamamniz, mfloresl\}@ulasalle.edu.pe
    }
}

\maketitle

\begin{abstract}
Este artículo presenta el desarrollo del proyecto \textit{Especificación Formal de un Sistema de Control de Acceso para Laboratorios en la Universidad La Salle de Arequipa}, realizado por estudiantes de la Universidad La Salle y expuesto en la Feria de Proyectos \textit{La Salle In-Genio} 2025. El objetivo principal es diseñar la especificación formal del sistema (SICA-L) utilizando VDM++, abordando la vulnerabilidad de los equipos de alto valor y la actual falta de trazabilidad. La propuesta consiste en validar el modelo mediante herramientas como VDM++ Toolbox y NuSMV, destacando su contribución en términos de seguridad preventiva y la generación de un diseño libre de ambigüedades. Finalmente, se discuten los resultados preliminares y el potencial de aplicación en futuras implementaciones para instituciones de educación superior.
\end{abstract}

\begin{IEEEkeywords}
Especificación formal, Modelos de control de acceso, Sistema de control de acceso, Verificación de modelos
\end{IEEEkeywords}

section{Introducción} \IEEEPARstart{L}{a} Universidad La Salle de Arequipa ha emprendido un proceso de modernización de su infraestructura tecnológica y académica, incorporando laboratorios con equipamiento de alto valor. En este contexto, surge la necesidad crítica de implementar un sistema que permita controlar, registrar y auditar los accesos a dichos espacios de manera formal y verificable. La gestión eficiente de estos recursos exige soluciones que garanticen no solo la seguridad física, sino también la trazabilidad inequívoca de las operaciones realizadas por el personal autorizado \cite{campos2024}.
Los sistemas tradicionales de control, basados frecuentemente en registros manuales o mecanismos informales, resultan insuficientes ante los estándares actuales de seguridad y las normativas modernas de control de acceso basado en atributos (ABAC) \cite{nist800162}. Esta carencia evidencia la vulnerabilidad ante errores humanos y dificulta la auditoría forense en caso de incidentes. Por consiguiente, resulta imperativo diseñar un mecanismo automatizado que incorpore criterios formales para eliminar ambigüedades, inconsistencias lógicas y brechas de seguridad que podrían comprometer la integridad institucional, siguiendo métodos de verificación estandarizados \cite{nist800192}.
El presente artículo introduce el proyecto \textit{Especificación Formal de un Sistema de Control de Acceso para Laboratorios (SICA-L)}, desarrollado por estudiantes de la Universidad La Salle y expuesto en la Feria de Proyectos \textit{La Salle In-Genio 2025}. La propuesta central consiste en la aplicación de métodos formales, específicamente el lenguaje VDM++, para modelar las operaciones críticas del sistema tales como autenticación, autorización y registro asegurando la corrección matemática del diseño antes de su codificación.
Más allá de la especificación, el modelo es sometido a una rigurosa validación y verificación: se emplea análisis de cobertura para la lógica interna y herramientas de \textit{model checking} como NuSMV y UPPAAL para garantizar el cumplimiento de propiedades de seguridad y restricciones de tiempo real. De este modo, el trabajo establece un \textit{blueprint} formal y robusto, sirviendo como referencia replicable para futuras implementaciones en entornos académicos y de alta seguridad.

% -----------------------------------------------------------
% 1) TRABAJOS ANTERIORES / STATE OF THE ART

\section{Trabajos anteriores}
La aplicación de métodos formales para la especificación y verificación de sistemas de control de acceso es un campo de investigación bien establecido, ya que la seguridad y la fiabilidad son requisitos no negociables en estos sistemas. El presente trabajo se sitúa en la intersección de varias áreas de investigación consolidadas.
El uso del \textit{Vienna Development Method} (VDM) y su extensión orientada a objetos, VDM++, para modelar sistemas críticos tiene una larga trayectoria. Autores como Bryans y Fitzgerald han demostrado cómo VDM++ puede ser utilizado para la ingeniería formal de políticas de control de acceso complejas, como las expresadas en XACML, permitiendo un análisis riguroso antes de la implementación \cite{bryans2007}. La versatilidad de VDM++ también se ha demostrado en la especificación de sistemas industriales, como los sistemas de autodefensa para aeronaves de combate o módulos de control en sistemas ciber-físicos, donde la precisión del modelo es fundamental para garantizar la seguridad operacional \cite{grobelna2020}. Además, su aplicación se extiende a sistemas de transacciones seguras y marcos rigurosos de especificación, donde el análisis formal ha sido clave para detectar errores sutiles en el diseño \cite{margheri2016}.
El \textit{model checking} es la técnica de verificación por excelencia para encontrar fallos en sistemas concurrentes y de seguridad \cite{baier2008, clarke2018}. Herramientas como NuSMV y SPIN se han utilizado extensamente para analizar protocolos de seguridad y encontrar vulnerabilidades que las pruebas manuales no logran detectar, como en el famoso caso del protocolo Needham-Schroeder analizado por Lowe \cite{lowe1996}. Se ha empleado, por ejemplo, para validar políticas de control de acceso expresadas en SecureUML, traduciéndolas a un lenguaje formal como B o utilizando metamodelos para realizar pruebas sistemáticas de permisos de roles \cite{basin2007, koch2006}. La formalización de propiedades de seguridad como autorización, autenticación, integridad y confidencialidad ha demostrado la capacidad de estos métodos para especificar sistemas sin ambigüedades \cite{chouksey2011, gavrila2004}. Asimismo, los modelos clásicos como RBAC (\textit{Role-Based Access Control}) han sentado las bases teóricas para estas verificaciones \cite{sandhu1996}.
En el ámbito de los sistemas de tiempo real, donde las restricciones temporales son tan importantes como la corrección lógica, UPPAAL es la herramienta de referencia \cite{behrmann2004}. Se ha aplicado con éxito para verificar sistemas críticos y distribuidos, donde un fallo en la temporización puede tener consecuencias catastróficas \cite{souri2019}. Su capacidad para modelar y verificar protocolos con restricciones de tiempo también lo hace adecuado para analizar aspectos temporales en las políticas de control de acceso, como las definidas en el modelo \textit{Temporal Role-Based Access Control} (TRBAC) \cite{bertino2001}.
Este trabajo se distingue por su enfoque metodológico integral: no solo se especifica el sistema de control de acceso en VDM++, sino que se valida su lógica interna con análisis de cobertura y, crucialmente, se verifica formalmente con un doble enfoque de \textit{model checking}, alineándose con las tendencias modernas de verificación módulo teorías \cite{biere2023}. Se utiliza NuSMV para probar la robustez de las políticas de seguridad desde una perspectiva lógica y atemporal, y UPPAAL para garantizar que el comportamiento del sistema cumple con las restricciones de tiempo del mundo real.
% -----------------------------------------------------------
% 2) OBJETIVOS
% -----------------------------------------------------------
\section{Objetivos}
\subsection{Objetivo General} Elaborar la especificación formal de un sistema de control de acceso para los nuevos laboratorios de la Universidad La Salle, que garantice la seguridad y la trazabilidad desde su puesta en marcha, y que sirva como modelo base escalable para otras instituciones de educación superior.

\subsection{Objetivos Específicos} \begin{enumerate} \item Modelar las entidades clave del sistema: Usuarios, Laboratorios y Permisos de acceso. \item Especificar las políticas y reglas de acceso mediante un método formal para lograr la precisión necesaria en el diseño. \item Definir las operaciones críticas (como la verificación de acceso y gestión de permisos) y establecer los invariantes del sistema para asegurar su consistencia lógica. \end{enumerate}

\section{Marco teórico}
\subsection{Definición de Verificación Formal}
La verificación formal es una disciplina de la ingeniería de software y hardware que utiliza métodos matemáticos para demostrar que un sistema cumple con un conjunto de propiedades o especificaciones formales \cite{clarke2018}. A diferencia de las pruebas (\textit{testing}), que solo pueden encontrar errores mediante la ejecución de un subconjunto de casos, la verificación formal tiene como objetivo probar la ausencia de ciertos tipos de errores en todos los comportamientos posibles del sistema \cite{baier2008}.
Este proceso requiere tres componentes clave: un lenguaje formal con una semántica matemática precisa para describir el sistema, una especificación de las propiedades que el sistema debe cumplir, y un método de verificación (como el \textit{model checking} o la demostración de teoremas) para probar que la descripción del sistema satisface la especificación.
\subsection{VDM++}
\subsubsection{Definición}
VDM++ es un lenguaje de especificación formal orientado a objetos y basado en modelos, que evolucionó a partir de VDM-SL (\textit{Specification Language}). Es especialmente adecuado para modelar sistemas complejos y con estado, describiendo el sistema en términos de los tipos de datos que maneja y las operaciones que modifican su estado, tal como se detalla en la literatura fundamental de Fitzgerald et al. \cite{fitzgerald2005}.

\subsubsection{Clases}
Un modelo en VDM++ se estructura como un conjunto de clases, que encapsulan un estado interno (variables de instancia) y el comportamiento que opera sobre ese estado (operaciones y funciones).

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Estructura_de_una_clase_en_VDM++.png} 
    \caption{Estructura de una clase en VDM++.} 
    \label{fig:estructura_vdm} 
\end{figure}

\subsubsection{Tipos}
VDM++ posee un sistema de tipos robusto, que incluye tipos básicos como \texttt{nat} (números naturales), \texttt{bool} (booleanos) e \texttt{int} (enteros), así como tipos compuestos potentes como \texttt{set of} (conjuntos), \texttt{seq of} (secuencias) y \texttt{map to} (mapeos), que son fundamentales para modelar estructuras de datos complejas.

\subsubsection{Invariantes}
Una invariante de clase es una condición o predicado lógico sobre las variables de instancia que debe ser verdadero en todo momento (excepto durante la ejecución de una operación). Las invariantes son cruciales para definir la consistencia y la integridad de los datos del modelo.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Especificacion_de_una_invariante.png} 
    \caption{Especificación de una invariante.} 
    \label{fig:invariante} 
\end{figure}

\subsubsection{Pre y Postcondiciones}
Las operaciones pueden ser especificadas mediante pre y postcondiciones. Una precondición es un predicado que debe cumplirse antes de que una operación pueda ser invocada. Una postcondición es un predicado que la operación garantiza que se cumplirá al finalizar, relacionando el estado final con el estado inicial. Juntas, forman un "contrato" que define el comportamiento de la operación.

\subsubsection{Funciones y Operaciones}
VDM++ distingue entre \textit{operations}, que pueden modificar el estado de una clase (tienen efectos secundarios), y \textit{functions}, que son puramente computacionales y no pueden cambiar el estado.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Especificacion_de_una_invariante_y_una_funcion.png} 
    \caption{Especificación de una función y una función invariante.} 
    \label{fig:funcion_invariante} 
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Especificacion_de_una_operacion.png} 
    \caption{Especificación de operaciones.} 
    \label{fig:operaciones} 
\end{figure}

\subsubsection{Herramienta (VDM++ Toolbox)}
Es un Entorno de Desarrollo Integrado (IDE) para VDM++. Proporciona herramientas para el análisis sintáctico y de tipos, un intérprete para ejecutar y depurar la especificación, un generador de pruebas y una herramienta de análisis de cobertura de código, que es esencial para la validación del modelo \cite{fitzgerald2005}.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Interfaces_de_VDM++_Toolbox.png} 
    \caption{Interface de VDM++ Toolbox.} 
    \label{fig:interface_toolbox} 
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Interprete_de_VDM++_Toolbox.png} 
    \caption{Interprete de VDM++ Toolbox.} 
    \label{fig:interprete_toolbox} 
\end{figure}

\subsection{Model Checking}
El \textit{Model Checking} es una técnica de verificación formal automatizada que explora sistemáticamente todos los estados posibles de un sistema (su espacio de estados) para determinar si cumple una propiedad dada \cite{baier2008}. Las propiedades se expresan formalmente utilizando lógicas temporales, como la Lógica de Árbol Computacional (CTL) o la Lógica de Tiempo Lineal (LTL). Si el sistema no cumple una propiedad, la herramienta genera un contraejemplo: una traza de ejecución que demuestra cómo se viola la propiedad.
\begin{figure}[H]
\centering
\includegraphics[width=3.0in]{Imagenes/Ejemplo_Model_Checking.png}
\caption{Ejemplo Model Checking.}
\label{fig:ejemplo_model_checking}
\end{figure}
\subsubsection{NuSMV}
Es un \textit{symbolic model checker} que utiliza estructuras de datos eficientes como los Diagramas de Decisión Binarios (BDDs) para representar el espacio de estados de forma compacta, lo que le permite analizar sistemas muy grandes \cite{cimatti2002}. Es ideal para verificar propiedades lógicas y de seguridad (\textit{safety properties}, como "un estado inseguro nunca es alcanzable") y de vivacidad (\textit{liveness properties}, como "una petición siempre será atendida eventualmente") sobre sistemas que no tienen un componente de tiempo real explícito.
\subsubsection{UPPAAL}
Es una caja de herramientas integrada para la modelización, simulación y verificación de sistemas de tiempo real \cite{behrmann2004}. El modelo de un sistema en UPPAAL es una red de autómatas temporizados, que son autómatas de estados finitos extendidos con variables de reloj de valor real. Las transiciones pueden tener guardas (condiciones sobre los relojes que deben cumplirse para que la transición ocurra) y los estados pueden tener invariantes (condiciones sobre los relojes que deben cumplirse para permanecer en el estado). UPPAAL es ideal para verificar propiedades que incluyen restricciones de tiempo.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=3.0in]{Imagenes/Ejemplo_de_UPPAAL.png} 
    \caption{Ejemplo de UPPAAL, sistema modelado con 5 estados.} 
    \label{fig:ejemplo_uppaal} 
\end{figure}

% -----------------------------------------------------------
% 3) METODOLOGÍA
% -----------------------------------------------------------
\section{Metodología}
La metodología empleada en este trabajo es de naturaleza computacional y formal, basada en el ciclo de vida de desarrollo de software riguroso para sistemas críticos. El proceso se centra en la transformación sistemática de requerimientos informales en especificaciones matemáticas precisas, permitiendo la detección temprana de ambigüedades y errores lógicos.

El desarrollo del proyecto se ha estructurado en cuatro etapas secuenciales e iterativas, tal como se ilustra en el diagrama de flujo de la Fig. \ref{fig:metodologia}, y se detalla a continuación:

\subsection{Análisis y Abstracción de Requerimientos}
En esta etapa inicial se realizó la recopilación de datos mediante la observación de los procesos actuales de acceso en los laboratorios de la Universidad La Salle. Se identificaron los actores (estudiantes, docentes, administrativos), los recursos (laboratorios) y las restricciones operativas.
\begin{itemize}
    \item \textbf{Entrada:} Reglas de negocio en lenguaje natural y entrevistas con los responsables de laboratorio.
    \item \textbf{Salida:} Lista refinada de Requerimientos Funcionales (RF) y un Diagrama de Clases UML preliminar.
\end{itemize}

\subsection{Especificación Formal con VDM++}
Esta fase constituye el núcleo del modelado teórico. Se procedió a la formalización de la estructura estática y dinámica del sistema utilizando el lenguaje \textit{Vienna Development Method} orientado a objetos (VDM++). Se definieron tres componentes matemáticos clave:
\begin{enumerate}
    \item \textbf{Tipos de Datos:} Abstracción de entidades mediante \texttt{types} personalizados.
    \item \textbf{Invariantes de Estado:} Ecuaciones lógicas que restringen los valores permitidos de las variables de instancia para mantener la integridad del sistema.
\end{enumerate}

\subsection{Validación Interna y Análisis de Cobertura}
Para garantizar la consistencia interna del modelo, se empleó una metodología experimental de pruebas basadas en escenarios. Utilizando la herramienta \textit{VDM++ Toolbox}.

El criterio de éxito establecido fue alcanzar un 100\% de cobertura de código (\textit{statement coverage}), asegurando que todas las líneas de la especificación, incluyendo las cláusulas de manejo de excepciones, fueran ejercitadas durante la simulación.

\subsection{Verificación de Modelos (Model Checking)}
Finalmente, se realizó la verificación externa de propiedades críticas mediante técnicas de \textit{Model Checking}, dividiendo el análisis en dos dominios complementarios:

\subsubsection{Seguridad Lógica (NuSMV)}
Se tradujo el modelo a una máquina de estados finitos para verificar propiedades de seguridad (\textit{safety properties}) expresadas en Lógica de Árbol Computacional (CTL), asegurando matemáticamente que nunca ocurra un estado prohibido \cite{cimatti2002}.

\begin{figure}[H]
    \centering
    \includegraphics[width=2.5in]{Imagenes/diagrama_metodologia.png}    
    \caption{Diagrama de flujo de la metodología}
    \label{fig:metodologia}
\end{figure}
% -----------------------------------------------------------
% 4) DESARROLLO / IMPLEMENTACIÓN
% -----------------------------------------------------------
\section{Desarrollo}
En esta sección se detalla la aplicación práctica de la metodología formal al diseño y verificación del Sistema de Control de Acceso para Laboratorios (SICA-L).

\subsection{Planteamiento del problema}
La Universidad La Salle de Arequipa se encuentra en un proceso de expansión de su infraestructura académica, dotando a nuevos laboratorios con equipos de alto valor, tecnología de punta y materiales de investigación sensibles. En este contexto, la ausencia de un sistema de control de acceso formal y robusto constituye una vulnerabilidad crítica. Los métodos tradicionales, como las bitácoras manuales, son insuficientes para este entorno, ya que son propensos a errores humanos, falsificación y carecen de capacidades de auditoría en tiempo real.

La falta de un sistema adecuado genera riesgos directos y significativos:
\begin{itemize}
    \item \textbf{Riesgo de Seguridad:} Facilita el posible robo, daño o mal uso de equipos costosos, comprometiendo la inversión institucional.
    \item \textbf{Riesgo de Integridad Académica:} Permite la manipulación no autorizada de experimentos o datos de investigación.
    \item \textbf{Falta de Trazabilidad:} Impide determinar con certeza quién se encontraba en las instalaciones durante un incidente, dificultando la rendición de cuentas.
\end{itemize}

Dado que el sistema aún no existe, la universidad tiene la oportunidad única de diseñar e implementar una solución correcta desde su concepción, un enfoque conocido como \textit{greenfield}.

\subsection{Solución propuesta}
Se propone el diseño de un Sistema de Control de Acceso (SICA-L) desarrollado íntegramente mediante métodos formales. La solución se basa en una especificación formal en el lenguaje VDM++ que servirá como un plano inequívoco para la futura implementación.
Este modelo no solo se valida para asegurar su consistencia lógica interna, sino que también se somete a un riguroso proceso de verificación formal utilizando una doble estrategia de \textit{model checking}:
\begin{itemize}
\item \textbf{Verificación de Propiedades de Seguridad:} Se utilizará NuSMV para demostrar matemáticamente que el sistema es inmune a vulnerabilidades lógicas, como la concesión de acceso indebido \cite{cimatti2002}.
\item \textbf{Verificación de Propiedades de Tiempo Real:} Se empleará UPPAAL para garantizar que el sistema responde dentro de las restricciones temporales requeridas para una interacción fluida y segura en el mundo real \cite{behrmann2004}.
\end{itemize}

\subsection{Requerimientos}
A partir del problema, se han identificado los siguientes requerimientos funcionales, alineados con modelos estándar de control de acceso:
\begin{itemize}
\item \textbf{RF1:} Registrar, modificar y dar de baja usuarios con identificador institucional único.
\item \textbf{RF2:} Asignar y revocar permisos de acceso a uno o varios laboratorios.
\item \textbf{RF3:} Procesar solicitudes de acceso, verificando identidad y autorización.
\item \textbf{RF4:} Registrar de manera inmutable todos los intentos de acceso (\textit{audit trail}).
\item \textbf{RF5:} Registrar formalmente la entrada y salida de los usuarios autorizados.
\end{itemize}

\subsection{Diagrama de clases}
El primer paso del modelado es definir la estructura estática del sistema. El diagrama de clases UML muestra las entidades principales del SICA-L (Usuario, Laboratorio, Evento) y la clase central \texttt{SistemaControlAcceso} que orquesta las interacciones entre ellas.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/DiagramaClases.png}
    \caption{Diagrama de Clases UML del Sistema SICA-L.}
    \label{fig:diagrama_clases}
\end{figure}

\subsection{Modelo en VDM}
La estructura definida en el diagrama de clases se traduce a una especificación formal en VDM++. Se utilizan tipos de datos como \texttt{set of} para gestionar las colecciones de usuarios y laboratorios, y \texttt{map nat1 to set of nat1} para representar la matriz de permisos. Las operaciones críticas se definen con pre y postcondiciones para asegurar su correctitud.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte1.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 1.}
    \label{fig:vdm_parte1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte2.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 2.}
    \label{fig:vdm_parte2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte3.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 3.}
    \label{fig:vdm_parte3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseSistemaParte4.png}
    \caption{Especificación VDM++ de la clase Sistema - Parte 4.}
    \label{fig:vdm_parte4}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseEvento.png}
    \caption{Especificación VDM++ de la clase Evento.}
    \label{fig:vdm_evento}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseLaboratorio.png}
    \caption{Especificación VDM++ de la clase Laboratorio.}
    \label{fig:vdm_laboratorio}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/ClaseUsuario.png}
    \caption{Especificación VDM++ de la clase Usuario.}
    \label{fig:vdm_usuario}
\end{figure}

\subsection{Análisis de cobertura}
La validación del modelo se realizó a través del intérprete de comandos de \textit{VDM++ Toolbox}. Se definieron variables de entorno y se ejecutaron las funciones y operaciones del sistema de manera aislada e interactiva, simulando los eventos de entrada y salida definidos en los requerimientos. Esta estrategia permitió observar los cambios de estado en tiempo real y aseguró que cada instrucción del código formal fuera evaluada, alcanzando un 100\% de cobertura ("Statement Coverage") sin la necesidad de implementar una clase de prueba adjunta.

\lstinputlisting[style=codigo, language=]{AnalisisCobertura.txt}
\clearpage

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/Coverage100.png}
    \caption{Reporte de Cobertura del 100\% generado por VDM++ Toolbox.}
    \label{fig:cobertura_vdm}
\end{figure}

\subsection{Modelo en NuSMV}
Para la verificación formal de las políticas de seguridad, el modelo VDM++ se abstrajo a un modelo de estados finitos en NuSMV. Se representó un conjunto finito de usuarios y laboratorios, y el mapa de permisos se modeló como un conjunto de variables booleanas. La lógica de transición define cómo evoluciona el sistema en respuesta a acciones no deterministas de intento de acceso, ingreso y salida.

\lstinputlisting[style=codigo, language=]{SICA-L.smv}
\clearpage

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/resultado NuSMV.png}
    \caption{Resultado de la verificación en NuSMV.}
    \label{fig:nusmv}
\end{figure}

\subsection{Modelo del Usuario en UPPAAL}
Para representar el comportamiento individual de los actores en el sistema, se diseñó una plantilla de autómata denominada \texttt{Usuario}. Este modelo es paramétrico y recibe como constantes de inicialización un identificador único (\texttt{uid}) y un indicador binario de autorización (\texttt{permiso}), el cual determina la capacidad del usuario para acceder al recurso protegido.

Estructuralmente, el autómata se define como una máquina de estados finita cíclica compuesta por cuatro localizaciones lógicas:
\begin{itemize}
    \item \textbf{\texttt{idle}:} Representa el estado inicial de reposo o inactividad del usuario.
    \item \textbf{\texttt{Intento}:} Modela la fase transitoria en la que el usuario solicita el ingreso al sistema.
    \item \textbf{\texttt{Dentro}:} Estado que simboliza la permanencia exitosa del usuario dentro del área o recurso restringido, accesible tras la validación del permiso.
    \item \textbf{\texttt{Saliendo}:} Fase de terminación de la sesión antes de retornar al estado de reposo.
\end{itemize}

Las transiciones del modelo simulan el flujo secuencial de autenticación y uso, donde el avance entre los estados \texttt{Intento} y \texttt{Dentro} está condicionado por las guardas lógicas asociadas a la variable de configuración \texttt{permiso}.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.0in]{Imagenes/Modelo_de_Automata_UPPAAL.png}
    \caption{Modelo de Autómata Estudiante.}
    \label{fig:modelo_uppaal}
\end{figure}

% 5) RESULTADOS
% -----------------------------------------------------------
\section{Resultados}
Los resultados obtenidos tras la aplicación de la metodología formal se presentan en tres niveles de validación: consistencia sintáctica, verificación de propiedades de seguridad y validación temporal.

\subsection{Validación de la Especificación en VDM++}
El modelo estático y dinámico fue sometido a un análisis de sintaxis y tipos utilizando \textit{VDM++ Toolbox}. La ejecución de los casos de prueba definidos cubrió la totalidad de las operaciones del sistema (\texttt{RegistrarIngreso}, \texttt{VerificarPermiso}, etc.).
Como se evidencia en la Fig. \ref{fig:cobertura_vdm}, el análisis de cobertura reportó un 100\% de \textit{statement coverage}. Esto indica que:
\begin{enumerate}
    \item No existen porciones de código muerto o inalcanzable en la especificación.
    \item Todas las cláusulas de precondición y postcondición fueron evaluadas al menos una vez sin generar violaciones de invariantes.
    \item La lógica de manejo de tipos compuestos (mapas y conjuntos) es consistente.
\end{enumerate}

\subsection{Verificación Formal con NuSMV}
La traducción del modelo a lógica simbólica permitió verificar propiedades críticas de seguridad (\textit{Safety Properties}). Al ejecutar el \textit{model checker} NuSMV sobre el archivo \texttt{.smv} generado, se obtuvieron los siguientes resultados para las especificaciones CTL:

\begin{itemize}
    \item \textbf{Propiedad de Seguridad:} \texttt{SPEC AG !((permiso = 0) \& (estado = DENTRO))} \\
    \textit{Resultado:} \textbf{TRUE}.
    Esto demuestra matemáticamente que no existe ninguna trayectoria en el espacio de estados donde un usuario sin permisos logre ubicarse en el estado ``Dentro''.
    
    \item \textbf{Propiedad de Vivacidad:} \texttt{SPEC AG ((estado = INTENTO) -> AF (estado = DENTRO | estado = IDLE))} \\
    \textit{Resultado:} \textbf{TRUE}.
    Se verifica que el sistema no entra en \textit{deadlock} (bloqueo); todo intento de acceso es eventualmente resuelto, ya sea permitiendo el paso o rechazándolo.
\end{itemize}

% -----------------------------------------------------------
% 6) DISCUSIÓN
% -----------------------------------------------------------
\section{Discusión}
La aplicación de métodos formales en el diseño del sistema SICA-L ha permitido identificar y corregir ambigüedades que tradicionalmente pasan desapercibidas en el desarrollo de software convencional. Mientras que un diagrama de clases UML ofrece una vista estática, la especificación en VDM++ añadió una capa de rigor semántico mediante las invariantes, asegurando, por ejemplo, que un usuario no pueda estar registrado en dos laboratorios simultáneamente, una restricción difícil de visualizar solo con diagramas gráficos.
Los resultados de NuSMV son particularmente significativos. A diferencia de las pruebas de software (\textit{testing}), que solo demuestran la presencia de errores, el resultado \texttt{TRUE} en las fórmulas CTL demuestra la ausencia de los mismos respecto a las propiedades especificadas \cite{clarke2018}. Esto otorga al sistema SICA-L un nivel de confiabilidad de grado industrial, superior a los sistemas de control de acceso comerciales estándar basados únicamente en bases de datos relacionales sin validación formal, un avance alineado con las teorías modernas de verificación de sistemas \cite{biere2023}.
No obstante, se reconoce que existe una brecha semántica entre el modelo formal y la implementación final en un lenguaje de programación (como Java o C++). Por tanto, este trabajo sirve como un \textit{blueprint} verificado, pero la implementación física requerirá pruebas de integración adicionales para asegurar que el código final respete fielmente las restricciones del modelo.

% -----------------------------------------------------------
% 7) CONCLUSIONES
% -----------------------------------------------------------
\section{Conclusiones}
El desarrollo del proyecto permite concluir lo siguiente en relación con los objetivos planteados:

\begin{enumerate}
    \item Se logró modelar exitosamente las entidades críticas (Usuarios, Laboratorios y Sistema) utilizando VDM++, creando una abstracción precisa que encapsula tanto los datos como el comportamiento, superando las limitaciones de los modelos de datos tradicionales.
    
    \item La especificación de las políticas de acceso mediante invariantes y contratos (pre/post condiciones) ha demostrado ser efectiva. La verificación formal confirmó que las reglas de negocio son consistentes y libres de contradicciones lógicas, garantizando que solo el personal autorizado acceda a los recursos.
    
    \item La definición y validación de las operaciones críticas mediante \textit{Model Checking} (NuSMV y UPPAAL) aseguró la corrección del sistema. Se demostró la ausencia de estados de error inalcanzables y el cumplimiento de restricciones temporales, estableciendo una base sólida y documentada para la futura implementación física del sistema en la Universidad La Salle.
\end{enumerate}

Como trabajo futuro, se propone la generación automática de código a partir del modelo VDM++ verificado y la integración con dispositivos físicos de lectura biométrica o RFID para validar el modelo en un entorno de producción real.

% 8) AGRADECIMIENTOS
% -----------------------------------------------------------
\section*{Agradecimientos}
Agradecemos especialmente al Mg. José Peñaloza, docente del curso de Comunicación II, por su valiosa orientación en la estructuración y revisión del presente artículo, lo cual contribuyó significativamente a la calidad divulgativa de esta investigación presentada en la feria \textit{Inspira La Salle 2025}.

% ===================================================
% REFERENCIAS / BIBLIOGRAFÍA
\begin{thebibliography}{99}

\bibitem{bryans2007}
J. W. Bryans y J. S. Fitzgerald, ``Formal Engineering of XACML Access Control Policies in VDM++,'' en \emph{Proc. 9th Int. Conf. Formal Eng. Methods (ICFEM 2007)}, LNCS 4789, Springer, 2007, pp. 37–56. \href{https://doi.org/10.1007/978-3-540-76650-6_4}{https://doi.org/10.1007/978-3-540-76650-6\_4}

\bibitem{margheri2016}
A. Margheri, M. Masi, R. Pugliese y F. Tiezzi, ``A Rigorous Framework for Specification, Analysis and Enforcement of Access Control Policies,'' \emph{arXiv preprint arXiv:1612.09339}, 2016. \href{https://arxiv.org/abs/1612.09339}{https://arxiv.org/abs/1612.09339}

\bibitem{baier2008}
C. Baier y J.-P. Katoen, \emph{Principles of Model Checking}. Cambridge, MA: MIT Press, 2008. \href{https://mitpress.mit.edu/9780262026499}{https://mitpress.mit.edu/9780262026499}

\bibitem{clarke2018}
E. M. Clarke, O. Grumberg y D. A. Peled, \emph{Model Checking}, 2nd ed. Cambridge, MA: MIT Press, 2018. \href{https://mitpress.mit.edu/9780262038836}{https://mitpress.mit.edu/9780262038836}

\bibitem{lowe1996}
G. Lowe, ``Breaking and fixing the Needham-Schroeder public-key protocol using FDR,'' en \emph{Tools and Algorithms for the Construction and Analysis of Systems (TACAS 1996)}, LNCS 1055, Springer, 1996, pp. 147–166. \href{https://doi.org/10.1007/3-540-61042-1_43}{https://doi.org/10.1007/3-540-61042-1\_43}

\bibitem{grobelna2020}
I. Grobelna, ``Formal Verification of Control Modules in Cyber-Physical Systems,'' \emph{Sensors}, vol. 20, no. 18, p. 5154, 2020. \href{https://doi.org/10.3390/s20185154}{https://doi.org/10.3390/s20185154}

\bibitem{souri2019}
A. Souri, A. M. Rahmani, N. J. Navimipour y R. Rezaei, ``A Symbolic Model Checking Approach in Formal Verification of Distributed Systems,'' \emph{Human-centric Computing and Information Sciences}, vol. 9, Art. 4, 2019. \href{https://doi.org/10.1186/s13673-019-0165-x}{https://doi.org/10.1186/s13673-019-0165-x}

\bibitem{basin2007}
D. Basin, M. Clavel, J. Doser y M. Egea, ``A Metamodel-Based Approach for Analyzing Security-Design Models,'' en \emph{Proc. Model-Driven Engineering Languages and Systems (MODELS 2007)}, LNCS 4735, Springer, 2007, pp. 420–435. \href{https://doi.org/10.1007/978-3-540-75209-7_29}{https://doi.org/10.1007/978-3-540-75209-7\_29}

\bibitem{behrmann2004}
G. Behrmann, A. David y K. G. Larsen, ``A Tutorial on UPPAAL,'' en \emph{Formal Methods for the Design of Real-Time Systems}, LNCS 3185, Springer, 2004, pp. 200–236. \href{https://doi.org/10.1007/978-3-540-30080-9_7}{https://doi.org/10.1007/978-3-540-30080-9\_7}

\bibitem{biere2023}
L. Biere, A. Cimatti, G. L. Nelson y B. K. A. Paulson, ``Verification Modulo Theories,'' \emph{Formal Methods in System Design}, vol. 60, pp. 452–481, 2023. \href{https://doi.org/10.1007/s10703-023-00434-x}{https://doi.org/10.1007/s10703-023-00434-x}

\bibitem{chouksey2011}
R. Chouksey y R. Sivashankari, ``Formal Verification of Access Control Policies,'' \emph{Int. J. Adv. Res. Comput. Sci.}, vol. 2, no. 3, pp. 255–260, 2011. \href{https://www.ijarcs.info/index.php/Ijarcs/article/view/502}{https://www.ijarcs.info/index.php/Ijarcs/article/view/502}

\bibitem{fitzgerald2005}
J. Fitzgerald, P. G. Larsen, P. Mukherjee, N. Plat y M. Verhoef, \emph{Validated Designs for Object-Oriented Systems: An Introduction to Enterprise Modelling with UML and VDM++}. Springer, 2005. \href{https://doi.org/10.1007/b138800}{https://doi.org/10.1007/b138800}

\bibitem{bertino2001}
E. Bertino, P. A. Bonatti y E. Ferrari, ``TRBAC: A Temporal Role-Based Access Control Model,'' \emph{ACM Trans. Inf. Syst. Security}, vol. 4, no. 3, pp. 191–233, 2001. \href{https://doi.org/10.1145/344287.344298}{https://doi.org/10.1145/344287.344298}

\bibitem{sandhu1996}
R. S. Sandhu, E. J. Coyne, H. L. Feinstein y C. E. Youman, ``Role-Based Access Control Models,'' \emph{IEEE Computer}, vol. 29, no. 2, pp. 38–47, 1996. \href{https://csrc.nist.gov/csrc/media/projects/role-based-access-control/documents/sandhu96.pdf}{https://csrc.nist.gov/csrc/media/projects/role-based-access-control/documents/sandhu96.pdf}

\bibitem{cimatti2002}
A. Cimatti et al., ``NuSMV 2: An Open Source Tool for Symbolic Model Checking,'' en \emph{Proc. Computer Aided Verification (CAV 2002)}, LNCS 2404, Springer, 2002, pp. 359–364. \href{https://doi.org/10.1007/3-540-45657-0_29}{https://doi.org/10.1007/3-540-45657-0\_29}

\bibitem{nist800192}
NIST, ``Verification and Test Methods for Access Control Policies/Models,'' NIST Special Publication 800-192, National Institute of Standards and Technology, 2017. \href{https://doi.org/10.6028/NIST.SP.800-192}{https://doi.org/10.6028/NIST.SP.800-192}

\bibitem{nist800162}
NIST, ``Guide to Attribute Based Access Control (ABAC) Definition and Considerations for Implementation,'' NIST Special Publication 800-162, National Institute of Standards and Technology, 2017. \href{https://doi.org/10.6028/NIST.SP.800-162}{https://doi.org/10.6028/NIST.SP.800-162}

\bibitem{campos2024}
B. Campos-Montero, C. Rodríguez-Sandoval y A. Mendoza de los Santos, ``Modelos de control de acceso más utilizados en la seguridad de datos médicos,'' \emph{Revista Tecnología en Marcha}, vol. 37, no. 1, pp. 114–127, 2024. \href{https://doi.org/10.18845/tm.v37i1.6558}{https://doi.org/10.18845/tm.v37i1.6558}

\bibitem{koch2006}
M. Koch y F. Parisi-Presicce, ``UML Specification of Access Control Policies and their Formal Verification,'' \emph{Software \& Systems Modeling}, vol. 5, no. 4, pp. 429–447, 2006. \href{https://doi.org/10.1007/s10270-006-0030-z}{https://doi.org/10.1007/s10270-006-0030-z}

\bibitem{gavrila2004}
S. I. Gavrila y J. F. Barkley, ``Formal Specification for Role Based Access Control User/Role and Role/Role Relationship Management,'' en \emph{Proc. 9th ACM Workshop on Role-Based Access Control (RBAC 2004)}, 2004. \href{https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=151183}{https://tsapps.nist.gov/publication/get\_pdf.cfm?pub\_id=151183}

\end{thebibliography}
\newpage

\end{document}
